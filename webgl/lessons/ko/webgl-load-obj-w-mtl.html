<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ko/webgl-load-obj-w-mtl.md. Do not edited directly -->
<!--
Copyright 2021 GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content=".MTL 파일을 파싱하는 방법">
<meta name="keywords" content="webgl graphics">
<meta name="thumbnail" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-load-obj-w-mtl_ko.jpg">

<meta property="og:title" content="WebGL Mtl로 Obj 로딩">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-load-obj-w-mtl_ko.jpg">
<meta property="og:description" content=".MTL 파일을 파싱하는 방법">
<meta property="og:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-load-obj-w-mtl.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webglfundamentals.org">
<meta name="twitter:title" content="WebGL Mtl로 Obj 로딩">
<meta name="twitter:url" content="https://webglfundamentals.org/webgl/lessons/ko/webgl-load-obj-w-mtl.html">
<meta name="twitter:description" content=".MTL 파일을 파싱하는 방법">
<meta name="twitter:image:src" content="https://webglfundamentals.org/webgl/lessons/screenshots/webgl-load-obj-w-mtl_ko.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webglfundamentals.org/#website",
      "url":"https://webglfundamentals.org/",
      "name":"WebglFundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-load-obj-w-mtl.html#primaryimage",
      "url":"https://webglfundamentals.org/webgl/lessons/screenshots/webgl-load-obj-w-mtl_ko.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-load-obj-w-mtl.html#webpage",
      "url":"https://webglfundamentals.org/webgl/lessons/ko/webgl-load-obj-w-mtl.html",
      "inLanguage":"ko",
      "name":"WebGL Mtl로 Obj 로딩",
      "keywords":"webgl graphics programming",
      "isPartOf":{
        "@id":"https://webglfundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webglfundamentals.org/webgl/lessons/ko/webgl-load-obj-w-mtl.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL Mtl로 Obj 로딩</title>
<link href="/webgl/lessons/resources/webglfundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/ko/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-load-obj-w-mtl.html">
  <link rel="alternate" hreflang="fr" href="https://webglfundamentals.org/webgl/lessons/fr/webgl-load-obj-w-mtl.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-load-obj-w-mtl.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-load-obj-w-mtl.html">
  <link rel="alternate" hreflang="pl" href="https://webglfundamentals.org/webgl/lessons/pl/webgl-load-obj-w-mtl.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-load-obj-w-mtl.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-load-obj-w-mtl.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-load-obj-w-mtl.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-load-obj-w-mtl.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-load-obj-w-mtl.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-load-obj-w-mtl.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-load-obj-w-mtl.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-load-obj-w-mtl.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-load-obj-w-mtl.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-load-obj-w-mtl.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-load-obj-w-mtl.html" >简体中文</a>
</select>


    <a href="#toc">목차</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ko/">WebGLFundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Mtl로 Obj 로딩</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p><a href="webgl-load-obj.html">이전 글</a>에서 .OBJ 파일을 파싱했었는데요.
이번 글에서는 이를 보완해주는 .MTL material 파일을 파싱해봅시다.</p>
<p><strong>유의사항:</strong> 이 .MTL 파서는 완벽하거나 모든 .MTL 파일을 처리하기 위한 게 아닙니다.
그보단 도중에 마주할 수 있는 것을 처리하기 위한 연습입니다.
그러니 큰 문제와 해결 방법이 있는 경우 하단에 댓글로 알려주시면 이 코드를 사용하기로 결정한 사람들에게 도움이 될 수 있습니다.</p>
<p><a href="https://sketchfab.com/">Sketchfab</a>에서 찾은 <a href="https://sketchfab.com/haytonm">haytonm</a>의 <a href="http://creativecommons.org/licenses/by/4.0/">CC-BY 4.0</a> <a href="https://sketchfab.com/3d-models/chair-aa2acddb218646a59ece132bf95aa558">의자</a>를 로드했습니다.</p>
<div class="webgl_center"><img src="../../resources/models/chair/chair.jpg" style="width: 452px;"></div>

<p>이에 상응하는 .MTL 파일은 다음과 같습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"># Blender MTL File: &#39;None&#39;
# Material Count: 11

newmtl D1blinn1SG
Ns 323.999994
Ka 1.000000 1.000000 1.000000
Kd 0.500000 0.500000 0.500000
Ks 0.500000 0.500000 0.500000
Ke 0.0 0.0 0.0
Ni 1.000000
d 1.000000
illum 2

newmtl D1lambert2SG
Ns 323.999994
Ka 1.000000 1.000000 1.000000
Kd 0.020000 0.020000 0.020000
Ks 0.500000 0.500000 0.500000
Ke 0.0 0.0 0.0
Ni 1.000000
d 1.000000
illum 2

newmtl D1lambert3SG
Ns 323.999994
Ka 1.000000 1.000000 1.000000
Kd 1.000000 1.000000 1.000000
Ks 0.500000 0.500000 0.500000
Ke 0.0 0.0 0.0
Ni 1.000000
d 1.000000
illum 2

...
</code></pre><p><a href="http://paulbourke.net/dataformats/mtl/">.MTL 파일 포맷의 설명</a>을 확인해보세요.
키워드 <code class="notranslate" translate="no">newmtl</code>로 새로운 material을 시작하고 아래에 해당 material에 대한 모든 설정이 있는 것을 볼 수 있습니다.
각 라인은 .OBJ 파일과 비슷한 키워드로 시작하므로 유사한 프레임워크로 시작할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function parseMTL(text) {
  const materials = {};
  let material;

  const keywords = {
    newmtl(parts, unparsedArgs) {
      material = {};
      materials[unparsedArgs] = material;
    },
  };

  const keywordRE = /(\w*)(?: )*(.*)/;
  const lines = text.split(&#39;\n&#39;);
  for (let lineNo = 0; lineNo &lt; lines.length; ++lineNo) {
    const line = lines[lineNo].trim();
    if (line === &#39;&#39; || line.startsWith(&#39;#&#39;)) {
      continue;
    }
    const m = keywordRE.exec(line);
    if (!m) {
      continue;
    }
    const [, keyword, unparsedArgs] = m;
    const parts = line.split(/\s+/).slice(1);
    const handler = keywords[keyword];
    if (!handler) {
      console.warn(&#39;unhandled keyword:&#39;, keyword);
      continue;
    }
    handler(parts, unparsedArgs);
  }

  return materials;
}
</code></pre>
<p>그런 다음 각 키워드에 대한 함수를 추가해야 하는데요.
문서에는 이렇게 적혀있습니다.</p>
<ul>
<li><code class="notranslate" translate="no">Ns</code>는 <a href="webgl-3d-lighting-point.html">점 조명에 대한 글</a>에서 다룬 반사광 설정입니다.</li>
<li><code class="notranslate" translate="no">Ka</code>는 material의 ambient color 입니다.</li>
<li><code class="notranslate" translate="no">Kd</code>는 <a href="webgl-3d-lighting-point.html">점 조명에 대한 글</a>에서 다룬 diffuse color 입니다.</li>
<li><code class="notranslate" translate="no">Ks</code>는 specular color 입니다.</li>
<li><code class="notranslate" translate="no">Ke</code>는 emissive color 입니다.</li>
<li><code class="notranslate" translate="no">Ni</code>는 optical density 입니다. 이건 사용하지 않을 겁니다.</li>
<li><code class="notranslate" translate="no">d</code>는 투명도인 &quot;dissolve&quot;를 나타냅니다.</li>
<li><code class="notranslate" translate="no">illum</code>은 조명의 종류를 지정합니다. 문서에는 11개의 종류가 나열되어 있습니다. 일단 이건 무시할 겁니다.</li>
</ul>
<p>이 이름들을 그대로 유지할 것인지 여부를 토론했는데요.
수학자들은 짧은 이름을 좋아하는 것 같습니다.
대부분의 코드 스타일 가이드는 기술적인 이름이 선호되므로 그렇게 하기로 결정했습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function parseMTL(text) {
  const materials = {};
  let material;

  const keywords = {
    newmtl(parts, unparsedArgs) {
      material = {};
      materials[unparsedArgs] = material;
    },
+    Ns(parts)     { material.shininess      = parseFloat(parts[0]); },
+    Ka(parts)     { material.ambient        = parts.map(parseFloat); },
+    Kd(parts)     { material.diffuse        = parts.map(parseFloat); },
+    Ks(parts)     { material.specular       = parts.map(parseFloat); },
+    Ke(parts)     { material.emissive       = parts.map(parseFloat); },
+    Ni(parts)     { material.opticalDensity = parseFloat(parts[0]); },
+    d(parts)      { material.opacity        = parseFloat(parts[0]); },
+    illum(parts)  { material.illum          = parseInt(parts[0]); },
  };

  ...

  return materials;
}
</code></pre>
<p>또한 각 .MTL 파일에 대한 경로를 추측할지 수동으로 지정할지 여부도 토론했는데요.
다시 말해 이렇게 하거나,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// pseudo code - .OBJ 및 .MTL 파일에 대한 경로를 수동으로 지정
const obj = downloadAndParseObj(pathToOBJFile);
const materials = downloadAndParseMtl(pathToMTLFile);
</code></pre><p>이렇게 할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// pseudo code - .OBJ 파일을 기반으로 .MTL 파일의 경로를 추측
const obj = downloadAndParseObj(pathToOBJFile);
const materials = downloadAndParseMtl(pathToOBJFile, obj);
</code></pre><p>좋은 생각인지 확신할 수는 없지만 저는 후자를 선택했습니다.
문서에 따르면 .OBJ 파일은 여러 .MTL 파일에 대한 참조를 포함할 수 있는데요.
그런 예제는 본 적이 없지만 문서 작성자는 그랬을 것이라 생각합니다.</p>
<p>뿐만 아니라 .OBJ 파일과 이름이 다른 .MTL 파일도 본 적이 없습니다.
다시 말해 .OBJ 파일이 <code class="notranslate" translate="no">bananas.obj</code>일 때 .MTL 파일은 대부분 <code class="notranslate" translate="no">bananas.mtl</code>인 것 같습니다.</p>
<p>스펙에 따르면 .MTL 파일은 .OBJ 파일에서 지정하므로 .MTL 파일의 경로를 산출하기로 결정했습니다.</p>
<p><a href="webgl-load-obj.html">이전 글</a>의 코드로 시작하여 .OBJ 파일에 대한 URL을 분리한 다음, .OBJ 파일과 관련된 .MTL 파일의 새로운 URL을 만듭니다.
마지막으로 모든 걸 로드하고, 단순 텍스트 파일이기 때문에 이들을 연결한 다음, 그걸 파서에 전달합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const response = await fetch(&#39;resources/models/chair/chair.obj&#39;);
+const objHref = &#39;resources/models/chair/chair.obj&#39;;
+const response = await fetch(objHref);
const text = await response.text();
const obj = parseOBJ(text);
+const baseHref = new URL(objHref, window.location.href);
+const matTexts = await Promise.all(obj.materialLibs.map(async filename =&gt; {
+  const matHref = new URL(filename, baseHref).href;
+  const response = await fetch(matHref);
+  return await response.text();
+}));
+const materials = parseMTL(matTexts.join(&#39;\n&#39;));
</code></pre>
<p>이제 materials을 사용해야 합니다.
먼저 parts를 설정할 때 .OBJ 파일에서 가져온 material의 이름을 사용하고, 로드한 materials에서 material을 찾는 데 사용할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const parts = obj.geometries.map(({data}) =&gt; {
+const parts = obj.geometries.map(({material, data}) =&gt; {

  ...

  // gl.createBuffer, gl.bindBuffer, gl.bufferData 호출로 각 배열의 버퍼 생성
  const bufferInfo = webglUtils.createBufferInfoFromArrays(gl, data);
  return {
-    material: {
-      u_diffuse: [1, 1, 1, 1],
-    },
+    material: materials[material],
    bufferInfo,
  };
});
</code></pre>
<p>도우미를 렌더링할 때 2개 이상의 uniform 값 세트를 전달할 수 있습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render(time) {

  ...

  for (const {bufferInfo, material} of parts) {
    // gl.bindBuffer, gl.enableVertexAttribArray, gl.vertexAttribPointer 호출
    webglUtils.setBuffersAndAttributes(gl, meshProgramInfo, bufferInfo);
    // gl.uniform 호출
    webglUtils.setUniforms(meshProgramInfo, {
      u_world,
-      u_diffuse: material.u_diffuse,
-    });
+    }, material);
    // gl.drawArrays 혹은 gl.drawElements 호출
    webglUtils.drawBufferInfo(gl, bufferInfo);
  }

  requestAnimationFrame(render);
}
</code></pre>
<p>그런 다음 셰이더를 수정해야 합니다.
Material에 반사 설정이 있기 때문에, <a href="webgl-3d-lighting-point.html">점 조명에 대한 글</a>에서 한 가지 차이점을 제외하고 반사 계산을 추가하려고 하는데, 점 조명 대신 방향성 조명에서 반사광을 계산할 겁니다.</p>
<p><code class="notranslate" translate="no">ambient</code>와 <code class="notranslate" translate="no">emissive</code>는 설명이 필요할 것 같은데요.
<code class="notranslate" translate="no">ambient</code>는 방향이 없는 조명의 material 색상입니다.
이를 <code class="notranslate" translate="no">u_ambientLight</code> 색상으로 곱하고 확인하고 싶다면 조명을 더 어두운 색상으로 설정할 수 있습니다.
This tends to wash thing out.</p>
<p><code class="notranslate" translate="no">emissive</code>는 모든 조명에서 분리된 material의 색상이므로 추가하기만 하면 됩니다.
<code class="notranslate" translate="no">emissive</code>는 빛나는 영역이 있을 때 사용됩니다.</p>
<p>여기 새로운 셰이더입니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `
attribute vec4 a_position;
attribute vec3 a_normal;
attribute vec4 a_color;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
+uniform vec3 u_viewWorldPosition;

varying vec3 v_normal;
+varying vec3 v_surfaceToView;
varying vec4 v_color;

void main() {
-  gl_Position = u_projection * u_view * a_position;
+  vec4 worldPosition = u_world * a_position;
+  gl_Position = u_projection * u_view * worldPosition;
+  v_surfaceToView = u_viewWorldPosition - worldPosition.xyz;
  v_normal = mat3(u_world) * a_normal;
  v_color = a_color;
}
`;

const fs = `
precision highp float;

varying vec3 v_normal;
+varying vec3 v_surfaceToView;
varying vec4 v_color;

-uniform vec4 u_diffuse;
+uniform vec3 diffuse;
+uniform vec3 ambient;
+uniform vec3 emissive;
+uniform vec3 specular;
+uniform float shininess;
+uniform float opacity;
uniform vec3 u_lightDirection;
+uniform vec3 u_ambientLight;

void main () {
  vec3 normal = normalize(v_normal);

+  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
+  vec3 halfVector = normalize(u_lightDirection + surfaceToViewDirection);

  float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
+  float specularLight = clamp(dot(normal, halfVector), 0.0, 1.0);

-  vec4 diffuse = u_diffuse * v_color;
+  vec3 effectiveDiffuse = diffuse * v_color.rgb;
+  float effectiveOpacity = opacity * v_color.a;

-  gl_FragColor = vec4(diffuse.rgb * fakeLight, diffuse.a);
+  gl_FragColor = vec4(
+      emissive +
+      ambient * u_ambientLight +
+      effectiveDiffuse * fakeLight +
+      specular * pow(specularLight, shininess),
+      effectiveOpacity);
}
`;
</code></pre>
<p>그리고 위 이미지와 상당히 유사하게 보이는 무언가를 얻게 됩니다.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-load-obj-w-mtl-no-textures.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-load-obj-w-mtl-no-textures.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>텍스처를 참조하는 .MTL을 가진 .OBJ 파일을 로드해봅시다.</p>
<p><a href="https://www.blendswap.com/user/ahedov">ahedov</a>의 <a href="https://www.blendswap.com/blends/view/69174">CC-BY-NC 3.0 풍차 3D 모델</a>을 찾았습니다.</p>
<div class="webgl_center"><img src="../../resources/models/windmill/windmill-obj.jpg"></div>

<p>.MTL 파일은 다음과 같습니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no"># Blender MTL File: &#39;windmill_001.blend&#39;
# Material Count: 2

newmtl Material
Ns 0.000000
Ka 1.000000 1.000000 1.000000
Kd 0.800000 0.800000 0.800000
Ks 0.000000 0.000000 0.000000
Ke 0.000000 0.000000 0.000000
Ni 1.000000
d 1.000000
illum 1
map_Kd windmill_001_lopatky_COL.jpg
map_Bump windmill_001_lopatky_NOR.jpg

newmtl windmill
Ns 0.000000
Ka 1.000000 1.000000 1.000000
Kd 0.800000 0.800000 0.800000
Ks 0.000000 0.000000 0.000000
Ke 0.000000 0.000000 0.000000
Ni 1.000000
d 1.000000
illum 1
map_Kd windmill_001_base_COL.jpg
map_Bump windmill_001_base_NOR.jpg
map_Ns windmill_001_base_SPEC.jpg
</code></pre><p><code class="notranslate" translate="no">map_Kd</code>, <code class="notranslate" translate="no">map_Bump</code>, <code class="notranslate" translate="no">map_Ns</code> 모두 이미지 파일을 지정하는 것을 볼 수 있는데요.
.MTL 파서에 추가해봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function parseMapArgs(unparsedArgs) {
  // TODO: 옵션 처리
  return unparsedArgs;
}

function parseMTL(text) {
  const materials = {};
  let material;

  const keywords = {
    newmtl(parts, unparsedArgs) {
      material = {};
      materials[unparsedArgs] = material;
    },
    Ns(parts)       { material.shininess      = parseFloat(parts[0]); },
    Ka(parts)       { material.ambient        = parts.map(parseFloat); },
    Kd(parts)       { material.diffuse        = parts.map(parseFloat); },
    Ks(parts)       { material.specular       = parts.map(parseFloat); },
    Ke(parts)       { material.emissive       = parts.map(parseFloat); },
+    map_Kd(parts, unparsedArgs)   { material.diffuseMap = parseMapArgs(unparsedArgs); },
+    map_Ns(parts, unparsedArgs)   { material.specularMap = parseMapArgs(unparsedArgs); },
+    map_Bump(parts, unparsedArgs) { material.normalMap = parseMapArgs(unparsedArgs); },
    Ni(parts)       { material.opticalDensity = parseFloat(parts[0]); },
    d(parts)        { material.opacity        = parseFloat(parts[0]); },
    illum(parts)    { material.illum          = parseInt(parts[0]); },
  };

  ...
</code></pre>
<p>참고: <a href="http://paulbourke.net/dataformats/mtl/">스펙</a>에 따르면 이 파일에서 볼 수 없는 추가 옵션들이 많기 때문에 <code class="notranslate" translate="no">parseMapArgs</code>를 만들었습니다.
이를 사용하려면 몇 가지 주요 리팩토링이 필요하지만 지금은 옵션 없이 공백이 있는 파일 이름을 처리하려고 합니다.</p>
<p>이 모든 텍스처를 로딩하기 위해 <a href="webgl-3d-textures.html">텍스처에 대한 글</a>의 코드를 약간 수정하여 사용할 겁니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function create1PixelTexture(gl, pixel) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                new Uint8Array(pixel));
  return texture;
}

function createTexture(gl, url) {
  const texture = create1PixelTexture(gl, [128, 192, 255, 255]);
  // 비동기적으로 이미지 로드
  const image = new Image();
  image.src = url;
  image.addEventListener(&#39;load&#39;, function() {
    // 이제 이미지가 로드되었기 때문에 텍스처로 복사
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);

    // 이미지의 두 치수 모두 2의 거듭 제곱인지 확인
    if (isPowerOf2(image.width) &amp;&amp; isPowerOf2(image.height)) {
       // 2의 거듭 제곱이면 mips 생성
       gl.generateMipmap(gl.TEXTURE_2D);
    } else {
       // 2의 거듭 제곱이 아니면 mips를 비활성화하고 가장 자리에 고정되도록 설정
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    }
  });
  return texture;
}
</code></pre>
<p>두 material이 같은 이미지를 참조할 수 있으므로 객체의 모든 텍스처를 파일 이름으로 유지하여 두 번 로드되지 않도록 합시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const textures = {};

// materials의 텍스처 로드
for (const material of Object.values(materials)) {
  Object.entries(material)
    .filter(([key]) =&gt; key.endsWith(&#39;Map&#39;))
    .forEach(([key, filename]) =&gt; {
      let texture = textures[filename];
      if (!texture) {
        const textureHref = new URL(filename, baseHref).href;
        texture = createTexture(gl, textureHref);
        textures[filename] = texture;
      }
      material[key] = texture;
    });
}
</code></pre>
<p>위 코드는 각 material의 각 속성을 검토합니다.
속성이 <code class="notranslate" translate="no">&quot;Map&quot;</code>으로 끝난다면 상대 URL을 생성하고, 텍스처를 생성한 다음, 다시 material에 할당합니다.
이미지를 비동기적으로 텍스처에 로드할 겁니다.</p>
<p>또한 텍스처를 참조하지 않아 모든 material에 대해 사용할 수 있는 흰색 픽셀 텍스처 하나를 넣을 겁니다.
이렇게 하면 동일한 셰이더를 사용할 수 있습니다.
그렇지 않은 텍스처가 있는 material과 텍스처가 없는 material에 다른 셰이더가 필요합니다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-const textures = {};
+const textures = {
+  defaultWhite: create1PixelTexture(gl, [255, 255, 255, 255]),
+};
</code></pre>
<p>누락된 material 매개 변수에 대한 기본값도 지정해봅시다.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">+const defaultMaterial = {
+  diffuse: [1, 1, 1],
+  diffuseMap: textures.defaultWhite,
+  ambient: [0, 0, 0],
+  specular: [1, 1, 1],
+  shininess: 400,
+  opacity: 1,
+};

const parts = obj.geometries.map(({material, data}) =&gt; {

  ...

  // gl.createBuffer, gl.bindBuffer, gl.bufferData 호출로 각 배열의 버퍼 생성
  const bufferInfo = webglUtils.createBufferInfoFromArrays(gl, data);
  return {
-    material: materials[material],
+    material: {
+      ...defaultMaterial,
+      ...materials[material],
+    },
    bufferInfo,
  };
});
</code></pre><p>To use the textures we need to change the shader.
Let&#39;s use them one at a time.
We&#39;ll first use the diffuse map.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `
attribute vec4 a_position;
attribute vec3 a_normal;
+attribute vec2 a_texcoord;
attribute vec4 a_color;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform vec3 u_viewWorldPosition;

varying vec3 v_normal;
varying vec3 v_surfaceToView;
+varying vec2 v_texcoord;
varying vec4 v_color;

void main() {
  vec4 worldPosition = u_world * a_position;
  gl_Position = u_projection * u_view * worldPosition;
  v_surfaceToView = u_viewWorldPosition - worldPosition.xyz;
  v_normal = mat3(u_world) * a_normal;
+  v_texcoord = a_texcoord;
  v_color = a_color;
}
`;

const fs = `#version 300 es
precision highp float;

varying vec3 v_normal;
varying vec3 v_surfaceToView;
+varying vec2 v_texcoord;
varying vec4 v_color;

uniform vec3 diffuse;
+uniform sampler2D diffuseMap;
uniform vec3 ambient;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
uniform vec3 u_lightDirection;
uniform vec3 u_ambientLight;

void main () {
  vec3 normal = normalize(v_normal);

  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
  vec3 halfVector = normalize(u_lightDirection + surfaceToViewDirection);

  float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
  float specularLight = clamp(dot(normal, halfVector), 0.0, 1.0);

-  vec3 effectiveDiffuse = diffuse.rgb * v_color.rgb;
-  float effectiveOpacity = v_color.a * opacity;
+  vec4 diffuseMapColor = texture2D(diffuseMap, v_texcoord);
+  vec3 effectiveDiffuse = diffuse * diffuseMapColor.rgb * v_color.rgb;
+  float effectiveOpacity = opacity * diffuseMapColor.a * v_color.a;

  gl_FragColor = vec4(
      emissive +
      ambient * u_ambientLight +
      effectiveDiffuse * fakeLight +
      specular * pow(specularLight, shininess),
      effectiveOpacity);
}
`;
</code></pre>
<p>And we get textures!</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-load-obj-w-mtl-w-textures.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-load-obj-w-mtl-w-textures.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>Looking back in the .MTL file we can see a <code class="notranslate" translate="no">map_Ks</code> which is basically
a black and white texture that specifies how shiny a particular surface
is or another way to think of it is how much of the specular reflection is used.</p>
<div class="webgl_center"><img src="../../resources/models/windmill/windmill_001_base_SPEC.jpg" style="width: 512px;"></div>

<p>To use it we just need to update the shader since we&#39;re already loading
all the textures.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `
precision highp float;

varying vec3 v_normal;
varying vec3 v_surfaceToView;
varying vec2 v_texcoord;
varying vec4 v_color;

uniform vec3 diffuse;
uniform sampler2D diffuseMap;
uniform vec3 ambient;
uniform vec3 emissive;
uniform vec3 specular;
+uniform sampler2D specularMap;
uniform float shininess;
uniform float opacity;
uniform vec3 u_lightDirection;
uniform vec3 u_ambientLight;

void main () {
  vec3 normal = normalize(v_normal);

  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
  vec3 halfVector = normalize(u_lightDirection + surfaceToViewDirection);

  float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
  float specularLight = clamp(dot(normal, halfVector), 0.0, 1.0);
+  vec4 specularMapColor = texture2D(specularMap, v_texcoord);
+  vec3 effectiveSpecular = specular * specularMapColor.rgb;

  vec4 diffuseMapColor = texture2D(diffuseMap, v_texcoord);
  vec3 effectiveDiffuse = diffuse * diffuseMapColor.rgb * v_color.rgb;
  float effectiveOpacity = opacity * diffuseMapColor.a * v_color.a;

  gl_FragColor = vec4(
      emissive +
      ambient * u_ambientLight +
      effectiveDiffuse * fakeLight +
-      specular * pow(specularLight, shininess),
+      effectiveSpecular * pow(specularLight, shininess),
      effectiveOpacity);
}
`;
</code></pre>
<p>We should also add a default for any material that doesn&#39;t have a specular map</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const defaultMaterial = {
  diffuse: [1, 1, 1],
  diffuseMap: textures.defaultWhite,
  ambient: [0, 0, 0],
  specular: [1, 1, 1],
+  specularMap: textures.defaultWhite,
  shininess: 400,
  opacity: 1,
};
</code></pre>
<p>It would be hard to see what this does with the material settings as they are in the
.MTL file so let&#39;s hack the specular settings so they&#39;re more pleasing.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// hack the materials so we can see the specular map
Object.values(materials).forEach(m =&gt; {
  m.shininess = 25;
  m.specular = [3, 2, 1];
});
</code></pre>
<p>And with that we can see only the windows and blades are set to show specular highlights.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-load-obj-w-mtl-w-specular-map.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-load-obj-w-mtl-w-specular-map.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>I&#39;m actually surprised the blades are set to reflect. If you look back up at the
.MTL file you&#39;ll see shininess <code class="notranslate" translate="no">Ns</code> is set to 0.0 which means the specular highlights
would be extremely blown out. But, also <code class="notranslate" translate="no">illum</code> is specified as 1 for both materials.
According to the docs illum 1 means</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">color = KaIa + Kd { SUM j=1..ls, (N * Lj)Ij }
</code></pre><p>Which translated into something more readable is</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">color = ambientColor * lightAmbient + diffuseColor * sumOfLightCalculations
</code></pre><p>As you can see there nothing about using specular whatsoever and yet the file
has a specular map! ¯_(ツ)_/¯. Specular highlights require illum 2 or higher.
This is my experience with .OBJ/.MTL files,
that there is always some manual tweaking required for the materials. How you fix
it is up to you. You can edit the .MTL file or you can add code. For now we&#39;ll
go the &quot;add code&quot; direction.</p>
<p>The last map this .MTL file uses is a <code class="notranslate" translate="no">map_Bump</code> bump map.
This is another place where the .OBJ/.MTL files show there age.
The file referenced is clearly a normal map, not a bump map.</p>
<div class="webgl_center"><img src="../../resources/models/windmill/windmill_001_base_NOR.jpg" style="width: 512px;"></div>

<p>There is no option in the .MTL file to specify normal maps or that bump maps
should be used as normal maps. We could use some heuristic like maybe if the
filename has &#39;nor&#39; in it? Or, maybe we could just assume all files referenced by
<code class="notranslate" translate="no">map_Bump</code> are normal maps in 2020 and beyond since I&#39;m not sure I&#39;ve seen an
.OBJ file with an actual bump map in over a decade. Let&#39;s go that route for now.</p>
<p>We&#39;ll grab the code for generating tangents from <a href="webgl-3d-lighting-normal-mapping.html">the article on normal mapping</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const parts = obj.geometries.map(({material, data}) =&gt; {
  ...

+  // generate tangents if we have the data to do so.
+  if (data.texcoord &amp;&amp; data.normal) {
+    data.tangent = generateTangents(data.position, data.texcoord);
+  } else {
+    // There are no tangents
+    data.tangent = { value: [1, 0, 0] };
+  }

  // create a buffer for each array by calling
  // gl.createBuffer, gl.bindBuffer, gl.bufferData

  const bufferInfo = twgl.createBufferInfoFromArrays(gl, data);
  const vao = twgl.createVAOFromBufferInfo(gl, meshProgramInfo, bufferInfo);
  return {
    material: {
      ...defaultMaterial,
      ...materials[material],
    },
    bufferInfo,
    vao,
  };
});
</code></pre>
<p>We also need to add a default normal map for materials that don&#39;t have one</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const textures = {
  defaultWhite: create1PixelTexture(gl, [255, 255, 255, 255]),
+  defaultNormal: create1PixelTexture(gl, [127, 127, 255, 0]),
};

...

const defaultMaterial = {
  diffuse: [1, 1, 1],
  diffuseMap: textures.defaultWhite,
+  normalMap: textures.defaultNormal,
  ambient: [0, 0, 0],
  specular: [1, 1, 1],
  specularMap: textures.defaultWhite,
  shininess: 400,
  opacity: 1,
};
...
</code></pre>
<p>And then we need to incorporate the shader changes from <a href="webgl-3d-lighting-normal-mapping.html">the article on normal mapping</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `
attribute vec4 a_position;
attribute vec3 a_normal;
+attribute vec3 a_tangent;
attribute vec2 a_texcoord;
attribute vec4 a_color;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform vec3 u_viewWorldPosition;

varying vec3 v_normal;
+varying vec3 v_tangent;
varying vec3 v_surfaceToView;
varying vec2 v_texcoord;
varying vec4 v_color;

void main() {
  vec4 worldPosition = u_world * a_position;
  gl_Position = u_projection * u_view * worldPosition;
  v_surfaceToView = u_viewWorldPosition - worldPosition.xyz;

-  v_normal = mat3(u_world) * a_normal;
+  mat3 normalMat = mat3(u_world);
+  v_normal = normalize(normalMat * a_normal);
+  v_tangent = normalize(normalMat * a_tangent);

  v_texcoord = a_texcoord;
  v_color = a_color;
}
`;

const fs = `
precision highp float;

varying vec3 v_normal;
+varying vec3 v_tangent;
varying vec3 v_surfaceToView;
varying vec2 v_texcoord;
varying vec4 v_color;

uniform vec3 diffuse;
uniform sampler2D diffuseMap;
uniform vec3 ambient;
uniform vec3 emissive;
uniform vec3 specular;
uniform sampler2D specularMap;
uniform float shininess;
uniform sampler2D normalMap;
uniform float opacity;
uniform vec3 u_lightDirection;
uniform vec3 u_ambientLight;

void main () {
  vec3 normal = normalize(v_normal);
+  vec3 tangent = normalize(v_tangent);
+  vec3 bitangent = normalize(cross(normal, tangent));
+
+  mat3 tbn = mat3(tangent, bitangent, normal);
+  normal = texture2D(normalMap, v_texcoord).rgb * 2. - 1.;
+  normal = normalize(tbn * normal);

  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
  vec3 halfVector = normalize(u_lightDirection + surfaceToViewDirection);

  float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
  float specularLight = clamp(dot(normal, halfVector), 0.0, 1.0);
  vec4 specularMapColor = texture2D(specularMap, v_texcoord);
  vec3 effectiveSpecular = specular * specularMapColor.rgb;

  vec4 diffuseMapColor = texture2D(diffuseMap, v_texcoord);
  vec3 effectiveDiffuse = diffuse * diffuseMapColor.rgb * v_color.rgb;
  float effectiveOpacity = opacity * diffuseMapColor.a * v_color.a;

  gl_FragColor = vec4(
      emissive +
      ambient * u_ambientLight +
      effectiveDiffuse * fakeLight +
      effectiveSpecular * pow(specularLight, shininess),
      effectiveOpacity);// * 0.0 + vec4(normal * 0.5 + 0.5 + effectiveSpecular * pow(specularLight, shininess), 1);
}
`;
</code></pre>
<p>And we that we get normal maps. Note: I moved the camera closer so they are easier to see.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-load-obj-w-mtl-w-normal-maps.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-load-obj-w-mtl-w-normal-maps.html" target="_blank">새 창을 열려면 여기를 클릭</a>
</div>

</p>
<p>I&#39;m sure there are way more features of the .MTL file we could try to support.
For example the <code class="notranslate" translate="no">refl</code> keyword specifies reflection maps which is another word
for <a href="webgl-environment-maps.html">environment map</a>. They also show the various
<code class="notranslate" translate="no">map_</code> keywords take a bunch of optional arguments. A few are:</p>
<ul>
<li><code class="notranslate" translate="no">-clamp on | off</code> specifies whether the texture repeats</li>
<li><code class="notranslate" translate="no">-mm base gain</code> specifies an offset and multiplier for texture values</li>
<li><code class="notranslate" translate="no">-o u v w</code> specifies an offset for texture coordinates. You&#39;d apply those using a texture matrix similar to what we did in <a href="webgl-2d-drawimage.html">the article on drawImage</a></li>
<li><code class="notranslate" translate="no">-s u v w</code> specifies a scale for texture coordinates. As above you&#39;d put those in a texture matrix</li>
</ul>
<p>I have no idea how many .MTL files are out there that use those settings or how
far to take it. For example if we add support for <code class="notranslate" translate="no">-o</code> and <code class="notranslate" translate="no">-s</code> do we want
to add that support for every texture under the assumption they might be different
for the diffuseMap vs the normalMap vs the specularMap etc..? That then requires
that we pass in a separate texture matrix for each texture which would then
require either passing a different set of texture coordinates per texture from
the vertex shader to the fragment shader or else doing the texture matrix
multiplication in the fragment shader instead of the traditional way of doing it
in the vertex shader.</p>
<p>A bigger point to take home is that adding support for every feature makes
the shaders bigger and more complicated. Above we have a form of <em>uber shader</em>,
a shader that tries to handle all cases. To make it work we passed in various
defaults. For example we set the <code class="notranslate" translate="no">diffuseMap</code> to a white texture so if we
load something without textures it will still display. The diffuse color will
be multiplied by white which is 1.0 so we&#39;ll just get the diffuse color.
Similarly we passed in a white default vertex color in case there are no
vertex colors.</p>
<p>This is a common way to get things working and if it works fast enough for your
needs then there is no reason to change it. But, it&#39;s more common to generate
shaders that turn these features on/off. If there are no vertex colors then
generate a shader, as in manipulate the shader strings, so they don&#39;t have an
<code class="notranslate" translate="no">a_color</code> attribute nor all the related code. Similarly if a material doesn&#39;t
have a diffuse map then generate a shader that doesn&#39;t have a <code class="notranslate" translate="no">uniform sampler2D
diffuseMap</code> and removes all related code. If it doesn&#39;t have any maps then we
don&#39;t need texture coordinates so we&#39;d leave those out as well.</p>
<p>When you add up all the combinations there can be 1000s of shader variations.
With just what we have above there is</p>
<ul>
<li>diffuseMap yes/no</li>
<li>specularMap yes/no</li>
<li>normalMap yes/no</li>
<li>vertex colors yes/no</li>
<li>ambientMap yes/no (we didn&#39;t support this but .MTL file does)</li>
<li>reflectionMap yes/no (we didn&#39;t support this but the .MTL file does)</li>
</ul>
<p>Just those represent 64 combinations. If we add in say 1 to 4 lights, and those
lights can be spot, or point, or, directional we end up with 8192 possible
shader feature combinations.</p>
<p>Managing all of that is a lot of work. This is one reason why many people
chose a 3D engine like <a href="https://threejs.org">three.js</a> instead of doing this
all themselves. But least hopefully this article gives some idea of
the types of things involved in displaying arbitrary 3D content.</p>
<div class="webgl_bottombar">
<h3>Avoid conditionals in shaders where possible</h3>
<p>The traditional advice is to avoid conditionals in shaders. As an example
we could have done something like this</p>
<pre class="prettyprint"><code class="notranslate" translate="no">
uniform bool hasDiffuseMap;
uniform vec4 diffuse;
uniform sampler2D diffuseMap

...
  vec4 effectiveDiffuse = diffuse;
  if (hasDiffuseMap) {
    effectiveDiffuse *= texture2D(diffuseMap, texcoord);
  }
...
</code></pre>
<p>Conditionals like that are generally discouraged because depending on the
GPU/driver they are often not very performant.</p>
<p>Either do like we did above and try to make the code have no conditionals. We used
a single 1x1 white pixel texture when there is no texture so our math would work
without a conditional.<p>
<p>Or, use different shaders. One that doesn't have the feature and one the does
and choose the correct one for each situation.</p>
</div>


    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-load-obj-w-mtl.html" >English</a>
    <option value="/webgl/lessons/fr/webgl-load-obj-w-mtl.html" >Français</a>
    <option value="/webgl/lessons/ja/webgl-load-obj-w-mtl.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-load-obj-w-mtl.html" selected>한국어</a>
    <option value="/webgl/lessons/pl/webgl-load-obj-w-mtl.html" >Polski</a>
    <option value="/webgl/lessons/pt-br/webgl-load-obj-w-mtl.html" >Portuguese</a>
    <option value="/webgl/lessons/ru/webgl-load-obj-w-mtl.html" >Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-load-obj-w-mtl.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>기초</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-fundamentals.html">기초</a></li>
<li><a href="/webgl/lessons/ko/webgl-how-it-works.html">작동 원리</a></li>
<li><a href="/webgl/lessons/ko/webgl-shaders-and-glsl.html">Shader 및 GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL 상태 다이어그램</a></li>
        </ul>
  <li>이미지 처리</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-image-processing.html">이미지 처리</a></li>
<li><a href="/webgl/lessons/ko/webgl-image-processing-continued.html">이미지 처리 심화</a></li>
        </ul>
  <li>2D Translation, Rotation, Scale, 행렬 수학</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrices.html">2D 행렬</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-orthographic.html">3D Orthographic</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective.html">3D Perspective</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-camera.html">3D 카메라</a></li>
        </ul>
  <li>조명</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-lighting-directional.html">방향성 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-point.html">점 조명</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-lighting-spot.html">스포트라이트</a></li>
        </ul>
  <li>구조와 구성</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-multiple-things.html">여러 물체 그리기</a></li>
<li><a href="/webgl/lessons/ko/webgl-scene-graph.html">장면 그래프</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-geometry-lathe.html">Geometry - Lathe</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj.html">.obj 파일 로딩</a></li>
<li><a href="/webgl/lessons/ko/webgl-load-obj-w-mtl.html">.mtl 파일로 .obj 로딩</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-3d-textures.html">텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-data-textures.html">데이터 텍스처</a></li>
<li><a href="/webgl/lessons/ko/webgl-2-textures.html">2개 이상의 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-cors-permission.html">Cross Origin Image</a></li>
<li><a href="/webgl/lessons/ko/webgl-3d-perspective-correct-texturemapping.html">원근 교정 텍스처 매핑</a></li>
<li><a href="/webgl/lessons/ko/webgl-planar-projection-mapping.html">평면 및 원근 투영 매핑</a></li>
        </ul>
  <li>텍스처 렌더링</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-render-to-texture.html">텍스처 렌더링</a></li>
        </ul>
  <li>그림자</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-shadows.html">그림자</a></li>
        </ul>
  <li>기법</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-matrix-stack.html">2D - 행렬 스택</a></li>
<li><a href="/webgl/lessons/ko/webgl-sprites.html">Sprite</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-cube-maps.html">Cubemap</a></li>
<li><a href="/webgl/lessons/ko/webgl-environment-maps.html">Environment Map</a></li>
<li><a href="/webgl/lessons/ko/webgl-skybox.html">Skybox</a></li>
<li><a href="/webgl/lessons/ko/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/ko/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ko/webgl-picking.html">Picking (clicking on stuff)</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-text-html.html">텍스트 - HTML</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-canvas2d.html">텍스트 - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-texture.html">텍스트 - 텍스처 사용</a></li>
<li><a href="/webgl/lessons/ko/webgl-text-glyphs.html">텍스트 - Glyph Texture 사용</a></li>
        </ul>
  <li>텍스처</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-ramp-textures.html">Ramp Textures (Toon Shading)</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Tip</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/ko/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/ko/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ko/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>최적화</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ko/webgl-instanced-drawing.html">Instanced Drawing</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-setup-and-installation.html">설정 및 설치</a></li>
<li><a href="/webgl/lessons/ko/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ko/webgl-resizing-the-canvas.html">Canvas 크기 조정</a></li>
<li><a href="/webgl/lessons/ko/webgl-animation.html">애니메이션</a></li>
<li><a href="/webgl/lessons/ko/webgl-points-lines-triangles.html">점, 선, 삼각형</a></li>
<li><a href="/webgl/lessons/ko/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/ko/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/ko/webgl-and-alpha.html">WebGL Alpha</a></li>
<li><a href="/webgl/lessons/ko/webgl-2d-vs-3d-library.html">2D vs 3D 라이브러리</a></li>
<li><a href="/webgl/lessons/ko/webgl-anti-patterns.html">Anti Pattern</a></li>
<li><a href="/webgl/lessons/ko/webgl-matrix-vs-math.html">WebGL 행렬 vs 수학 행렬</a></li>
<li><a href="/webgl/lessons/ko/webgl-precision-issues.html">정밀도 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#screenshot">Screenshot 찍기</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#preservedrawingbuffer">Canvas Clear 방지</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#tabindex">캔버스 키보드 입력</a></li>
<li><a href="/webgl/lessons/ko/webgl-tips.html#html-background">WebGL 배경 제작</a></li>
<li><a href="/webgl/lessons/ko/webgl-cross-platform-issues.html">Cross Platform 문제</a></li>
<li><a href="/webgl/lessons/ko/webgl-qna.html">질문 및 답변</a></li>
        </ul>
  <li>참고</li>
        <ul>
          <li><a href="/webgl/lessons/ko/webgl-attributes.html">Attribute</a></li>
<li><a href="/webgl/lessons/ko/webgl-texture-units.html">Texture Unit</a></li>
<li><a href="/webgl/lessons/ko/webgl-framebuffers.html">Framebuffer</a></li>
<li><a href="/webgl/lessons/ko/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ko/webgl-references.html">참고 자료</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">도우미 API 문서</a></li>
  <li><a href="https://twgljs.org">TWGL, 가벼운 WebGL 라이브러리</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl-fundamentals">Github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        
    <div>이슈/버그는? <a href="https://github.com/gfxfundamentals/webgl-fundamentals/issues">Github</a>에 이슈를 만들어주세요.</div>
    <div class="lesson-comment-notes">
      코드 블록은 <b>&lt;pre&gt;&lt;code&gt;</b>여기에 코드 입력<b>&lt;/code&gt;&lt;/pre&gt;</b>를 사용해주세요
    </div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webglfundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Mtl로 Obj 로딩';
            var disqus_title = 'WebGL Mtl로 Obj 로딩';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Thank you <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>for <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} contributions</a>",
  owner: "gfxfundamentals",
  repo: "webgl-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
(function() {
  if (window.location.hostname.indexOf("webglfundamentals.org") < 0) {
      return;
  }

  function addScript(src, type, fn) {
    const script = document.createElement('script');
    const firstScript = document.getElementsByTagName('script')[0];
    script.async = true;
    script.defer = true;
    script.type = type || 'javascript';
    if (fn) {
      script.addEventListener('load', fn);
    }
    script.src = src;
    firstScript.parentNode.insertBefore(script, firstScript);
  }

  // can't do this because it would eat contexts
  //addScript('//gpustats.org/stats.js', 'module');

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59804936-1', 'auto');
  ga('send', 'pageview');
}());
</script>


</html>



